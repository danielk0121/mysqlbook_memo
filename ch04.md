# ch04
4장 아키텍처

mysql 서버는
mysql 엔진과
스토리지 엔진
으로 구분할 수 있다

스토리지엔진은 핸들러 API 를 만족하면 
구현해서 MySQL 서버에 추가해서 사용 가능하다

mysql 서버에서 기본 제공되는 
InnoDB 스토리지 엔진
MyISAM 스토리지 엔진

mysql 엔진 =
커넥션 핸들러
SQL 인터페이스
SQL 파서
SQL 옵티마이저
캐시, 버퍼
=> 
클라이언트로 부터 들어오는 접속 요청 처리
SQL 파싱, 최적화 옵티마이저 등을 전담한다

스토리지 엔진 = InnoDB, MyISAM, Memory
=> 
실제 데이터를 디스크에 저장하거나 읽어오는 부분을 전담한다
테이블 단위로 스토리지 엔진을 설정할 수 있다
mysql 서버에서 스토리지 엔진은 여러개 사용이 가능하다

create table test_tab (fd1 INT, fd2 INT) engine=INNODB;

즉 클라이언트 측 담당은 MySQL 엔진이 담당하고
운영체제와 통신해야 하는 디스크 읽기쓰기 담당은 스토리지 엔진이 담당한다

---

핸들러 API

MySQL 엔진의 쿼리 실행기
쿼리 실행기에서 데이터를 읽고쓰기할때
스토리지엔진에 쓰기일기를 요청하는데
이때 사용되는게 핸들러 API

핸들러 API 사용 통계를 확인 가능
show global status like 'Handler%';
Handler_commit 2696
Handler_read_first 67
Handler_rollback 1
Handler_savepoint 0
...

---

MySQL 서버는 프로세스 기반이 아니라
스레드 기반으로 작동함

크게 포그라운드 스레드와 백그라운 스레드로 구분
performance_schema 에서 확인 가능
select * from performance_schema.threads ;
thread_id, name, type 등등

name 이 
thread/sql/one_connection 스레드가 있다
실제 사용자의요청을 처리하는 포그라운드 스레드 이다

동일한 이름의 스레드가 2개 이상인 경우는
MySQL 서버 설정에 의해 여러 스레드가 병렬 처리함을 의미한다 !

select name as thread_name, count(1) cnt 
from performance_schema.threads 
group by name having count(1) > 1 
order by 1 ;

| thread\_name | cnt |
| :--- | :--- |
| thread/innodb/io\_read\_thread | 4 |
| thread/innodb/io\_write\_thread | 4 |
| thread/innodb/srv\_worker\_thread | 3 |
| thread/mysqlx/acceptor\_network | 2 |
| thread/mysqlx/worker | 2 |
| thread/sql/one\_connection | 2 |

---

포그라운드 스레드 = 클라이언트 스레드

MySQL 에서 사용자 스레드와 포그라운드 스레드는 같은 의미로 사용된다

사용이 종료되면 스레드 캐시로 되돌아간다
스레드 캐시에 유지할 수 있는 최대 스레드 개수는 
thread_cache_size 시스템 변수로 설정한다

---

백그라운드 스레드

InnoDB 는 다음작업이 백그라운드로 처리된다

인서트 버퍼를 병합하는 스레드
로그를 디스크로 기록하는 스레드
InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
데이터를 버퍼로 읽어오는 스레드
잠금이나 데드락을 모니터링 하는 스레드

스레드 개수 설정 시스템 변수
innodb_write_io_threads
innodb_read_io_threads

사용자의 요청을 처리하는 도중 데이터 쓰기 작업은
지연되어 처리될 수 있지만
데이터 읽기 작업은 절대 지연될 수 없다
사용자가 select 쿼리를 실행했는데
요청된 select 는 10분뒤에 결과를 돌려주겠다
라고 응답하는 dbms 는 없다

---

서버에서 사용되는 메모리 공간은 크게
글로벌 메모리 영역
로컬 메모리 영역
으로 구분된다

글로벌 메모리 영역 =
InnoDB 버퍼 풀
MyISAM 키 캐시
바이너리 로그 버퍼
리두 로그 버퍼
테이블 캐시

세션 메모리 영역 = 
조인버퍼
정렬 버퍼
네트워크 버퍼
리드 버퍼

글로벌 메모리 영역
클라이언트 스레드 수와 무관하며
모든 스레드에 의해 공유된다

로컬 메모리 영역
세션 메모리 영역이라고도 표현하며
서버상에 존재하는 클라이언트 스레드가 
쿼리를 처리하는데 사용하는 메모리 영역이다

---

플러그인 스토리지 엔진 모델

MySQL 엔진이 각 스토리지 엔진에게
데이터를 읽어오거나 저장하도록 명령하려면
반드시 핸들러를 통해야 한다

Handler_ 로 시작하는 상태변수
mysql엔진이 스토리지엔진에게 
보낸 명령의 횟수를 의미하는 변수

실질적인 groupby나 orderby 등 복잡한 처리는
스토리지엔진 영역이 아니라
mysql엔진 처리 영역인 쿼리실행기에서 처리된다

하나의 쿼리 작업은 여러 하위작업으로 나뉘는데
각 하위작업이 mysql엔진영역에서 처리되는지
스토리지엔진영역에서 처리되는지 구분해야 한다

show engines;
show plugins;

---

쿼리 실행 구조

사용자가 sql 요청
쿼리파서 - 문법 확인
전처리기 - 객체, 권한 확인 등
옵티마이저
쿼리실행기
스토리지엔진
사용자에게 sql 결과 응답

핸들러는 결국 스토리지엔진을 의미한다

mysql8 으로 올라오면서 쿼리캐시 기능은 삭제되었다

---

트랜잭션 지원 메타데이터

테이블 구조정보, 스토어드 프로그램 정보 등을
데이터 딕셔너리 또는 메타데이터라고 한다
mysql5.7까지는 FRM파일에 저장하고 
일부 스토어드 프로그램을 TRN TRG PAR 파일로 관리했다

파일기반 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않는다
생성 또는 변경 도중 mysql 서버가 비정상적으로 종료되면 파일이 문제가 생긴다
이러한 현상을 데이터베이스나 테이블이 깨졌다 라고 한다

mysql8 부터는 테이블 구조정보나 스토어드 프로그램의 코드 관련 정보를 
모두 InnoDB 테이블에 저장하도록 개선됐다

데이터 딕셔너리
메타데이터
데이터베이스나 테이블이 깨졌다

---

InnoDB 스토리지 엔진 아키텍처

innodb는 스토리지엔진 중 거의 유일하게 레코드 기반 잠금을 제공한다

---

프라이머리 키에 의한 클러스터링

innodb 모든 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장된다
즉 프라이머리 키 값 순서대로 디스크에 저장된다는 뜻
모든 세컨더리 인덱스는 레코드의 주소대신 프라이머리 키값을 논리적인 주소로 사용한다

myisam 스토리지엔진은 클러스터링 키를 지원하지 않는다
그래서 프라이머리 키와 세컨더리 인덱스는 구조적으로
아무런 차이가 없다

---

외래키 지원

외래키 지원은 innodb 스토리지엔진 레벨에서 지원하는 기능
myisam 이나 memory 테이블에서는 사용 불가

innodb 에서 외래키는 부모테이블과 자식테이블 모두 해당 컬럼에 인덱스 생성이 필요하다

foreign_key_check 시스템변수

---

MVCC

multi version concurrency control

일반적으로 레코드 레벨 트랜잭션을 지원하는 dbms 가 제공하는 기능
mvcc 의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다
innodb 는 언두로그를 이용해 이 기능을 구현한다

멀티버전이라 함은 하나의 레코드에 대해
여러개의 버전이 동시에 관리된다는 의미다

이해를 위해 격리수준이 READ_COMMITED 인 mysql 서버에서
innodb 스토리지엔진을 사용하는 테이블의 데이터 변경을 
어떻게 처리하는지 살펴보자

innodb 버퍼풀 - 메모리
언두로그 - 메모리
데이터 파일 - 디스크

innodb가 ACID를 보장하기 때문에
일반적으로는 innodb 버퍼풀과 데이터파일은 동일한 상태라고
가정해도 무방하다

커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것이 아니다
이 언두 영역을 필요로하는 트랜잭션이 더는 없을때 삭제된다

---

잠금 없는 일관된 읽기

Non-Locking Consistent Read

innodb 스토리지엔진은 MVCC 기술을 이용해
잠금을 걸지 않고 읽기 작업을 수행한다

격리수준이 serializable 이 아닌
read_uncommited, read_commited, repeatable_read
수준인 경우 insert 와 연결되지 않은
순수한 읽기 select 작업은
다른 트랜잭션의 변경 작업과 무관하게
항상 잠금을 대기하지 않고 바로 실행된다

다른 사용자가 아직 커밋을 수행하지 않았다 하더라도
다른 사용자의 select 작업을 방해하지 않는다

innodb 에서는 변경되기 전의 데이터를 읽기 위해
언두 로그를 사용한다
즉, 잠겨진 레코드를 읽기 위해서 언두 로그를 사용한다

---

자동 데드락 감지

innodb 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지
확인하기 위해 잠금 대기 목록을 
그래프 형태로 관리한다

데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해
교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를
강제 종료한다

innodb_table_locks 시스템 변수
innodb 엔진은 상위 레이어인 mysql 엔진에서 관리되는
테이블 잠금(LOCK tables 명령)은 볼 수가 없어서
데드락 감지가 불확실 할 수도 있다
innodb_table_locks 변수를 활성화하면
innodb 엔진 내부의 레코드 잠금뿐 아니라
테이블 레벨의 잠금까지 감지할 수 있다
특별한 이유가 없다면 변수를 활성화하자

innodb_deadlock_detect = on/off
innodb_lock_wait_timeout = sec

---

자동화된 장애 복구

innodb_force_recovery = 1-6

---

innodb 버퍼 풀

디스크의 데이터 파일이나 인덱스 정보를 
메모리에 캐시해 두는 공간이다
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는
버퍼 역할도 같이 한다

---

버퍼 풀의 크기 설정

일반적으로 물리 메모리의 80% 정도를 innodb 버퍼풀로 설정하라는 말이 있는데, 단순하게 설정해서 되는 값은 아니다

레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 공간이다

mysql5.7 부터 innodb 버퍼 풀 크기를
동적으로 조절할 수 있다

운영체제 전체 메모리가 8GB 미만이라면 50%정도만
innodb 버퍼 풀로 설정하고
나머지 공간은 mysql 서버와 운영체제
그리고 다른 프로그램이 사용하는 공간으로 확보한다

innodb_buffer_pool_size

버퍼풀 크기를 줄이는 작업은 서비스 영향도가 매우 크다

innodb 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리된다
이는 버퍼풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다
그래서 버퍼풀의 크기 변경은 128MB 단위로 처리된다

innodb_buffer_pool_instances 시스템 변수
버퍼풀을 여러개로 분리해서 관리할 수 있다
각 버퍼풀은 버퍼풀 인스턴스라고 표현한다
기본적으로 버퍼풀 인스턴스의 개수는 8개로 초기화된다
전페 버퍼풀 메모리가 1GB 미만이면 인스턴스는 1개만 생성된다

---

버퍼 풀의 구조

innodb_pgae_size
버퍼풀 이라는 거대한 메모리 공간을 페이지 크기의 조각으로
쪼개어 innodb 엔진이 데이터를 필요로 할때
해당 데이터 페이지를 읽어서 각 조각에 저장한다

버퍼풀의 페이지 크기 조각을 관리하기 위해
LRU 리스트
플러시 flush 리스트
프리 free 리스트
3개 자료구조를 관리한다

프리 리스트: 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록

LRU 리스트
디스크로부터 한번 읽어온 페이지를 최대한 오랫동안
innodb 버퍼풀의 메모리에 유지해서 
디스크 읽기를 최소화 하는 것이 목적이다

플러시 리스트
디스크로 동기화되지 않은 데이터를 가진 데이터 페이지
이를 더티 페이지라고 한다
더티 페이지의 변경 시점 기준의 페이지 목록을 관리한다
플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야 한다

---

버퍼 풀과 리두 로그

innodb 버퍼풀은 데이터 캐시와 쓰기 버퍼링이라는 두가지 용도가 있는데, 단순히 버퍼풀의 메모리만 늘리는 것은 데이터 캐시 기능만 향상 시키는 것이다

클린 페이지 clean page
디스크에서 읽은 상태로 전혀 변경되지 않은 것

더티 페이지 dirty page
insert, update, delete 명령으로
변경된 데이터를 가진 것

더티 페이지는 디스크와 메모리(버퍼풀)의 
데이터 상태가 다르기 때문에
언젠가는 디스크로 기록돼야 한다

리두 로그는 순환 고리처럼 사용한다
그래서 데이터 변경이 계속 발생하면
리두 로그 파일에 기록됐던 로그 엔트리는
어느 순간 다른 것으로 덮어 쓰인다

전체 리두 로그 파일에서 
재사용 가능한 공간과
당장 재사용 불가능한 공간을
구분해서 괸리해야 한다

재사용 불가능한 공간 = Active Redo Log

리두 로그 파일의 공간은 계속 순환되어 재사용 되지만
매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖는다
이를 LSN Log Sequence Number 라고 한다

innodb 엔진은 주기적으로 체크포인트 이벤트를 발생시켜
리두 로그와 버퍼풀의 더티 페이지를 
디스크로 동기화한다

체크포인트가 발생하면
체크포인트 LSN 보다 작은 리두 로그 엔트리와 관련된
더티 페이지는 모두 디스크로 동기화돼야 한다

리두 로그 파일의 크기를 적절히 선택하기 어렵다면
버퍼풀의 크기가 100GB 이하 mysql 서버에서는
리두 로그 파일 전체 크기를 대략 5-10GB 수준으로 선택하고
필요할때마다 조금씩 늘린다

---

버퍼 풀 플러시 buffer pool flush

더티 페이지 플러시
더티 페이지를 디스크에 동기화하는 부분

버퍼풀에서 디스크로 기록되지 않은 더티 페이지들을
디스크에 동기화하기 위해 2개의 플러시 기능을 
백그라운드로 실행한다

플러시 리스트 flush_list 플러시
LRU 리스트 LRU_list 플러시

---

플러시 리스트 플러시

innodb 엔진은 주기적으로 Flush_list 플러시 함수를 호출해서
플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로
디스크에 동기화하는 작업을 수행한다

언제부터 얼마나 많은 더티 페이지를
한번에 디스크로 기록하느냐에 따라
사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리된다

innodb_page_cleaners
innodb_max_dirty_pages_pct_lwm
innodb_max_dirty_pages_pct
innodb_io_capacity
innodb_io_capacity_max
innodb_flush_neighbors
innodb_adaptive_flushing
innodb_adaptive_flushing_lwm

pct
percent

lwm
Low water mark
낮은 경계 값

클리너 스레드 cleaner thread
더티 페이지를 디스크로 동기화 하는 스레드

innodb_page_cleaners
innodb_buffer_pool_instances
가능하면 클리너 스레드 개수와
버퍼풀 인스턴스 개수를 동일하게 맞춰주자

innodb_max_dirty_pages_pct
기본적으로 전체 버퍼풀이 가진 페이지의 90%까지
더티 페이지를 가질 수 있는데, 때로는 이 값이 너무 높을 수 있다

버퍼풀은 더티 페이지를 많이 가지고 있을 수록
디스크 쓰기 작업을 버퍼링 함으로써
여러번의 디스크 쓰기를 한번으로 줄이는 효과를
높일 수 있다

disk io burst
버퍼풀에 더티 페이지가 많으면 많을수록
디스크 쓰기 폭발 disk io burst 현상 발생 가능성이 높아진다

innodb_io_capacity
이 값을 기준으로 더티 페이지 쓰기를 실행한다
디스크로 기록되는 더티 페이지 개수보다
더 많은 더티 페이지가 발생하면
버퍼풀에 더티 페이지가 계속 증가하게 되고
어느 순간 더티 페이지 비율이 90%를 넘어가게 되고
급작스럽게 더티 페이지를 디스크로 기록해야 한다고 판단한다

innodb_max_dirty_pages_pct_lwm
이런 문제를 위해 일정 수준 이상의 더티 페이지가
발생하면 조금씩 더티 페이지를 디스크로 기록하게 하고 있다
기본값은 10% 수준인데, 
만약 디스크 쓰기가 너무 많이 발생하고
더티 페이지 비율이 너무 낮은 상태로 머물러 있다면
조금 더 높은 값으로 조정하여 
디스크 쓰기 횟수를 줄이는 효과를 얻을 수 있다

innodb_io_capacity
innodb_io_capacity_max
디비서버에서 어느정도의 디스크 읽고 쓰기가
가능한지 설정하는 값이다
디스크 읽고 쓰기란 innodb 엔진이 버퍼풀의 더티 페이지 쓰기를 말한다
innodb 엔진은 쿼리 처리를 위해 디스크 읽기도 해야한다
그래서 하드웨어 디스크가 초당 1000 IOPS 라고 해서
그대로 사용하면 안된다

innodb_adaptive_flushing
innodb_adaptive_flushing_lwm
활성화되면 innodb 엔진은 단순히
버퍼풀의 더티페이지 비율이나
innodb_io_capacity, innodb_io_capacity_max
설정값이 아니라 새로운 알고리즘을 사용해 자동 조정한다

어느정도 디스크로 기록해야 할지는
사실 어느 정도 속도로 더티 페이지가 생성되는지를
분석하는 것인데
이는 결국 리두 로그가 어느 정도 속도로 증가하는지를
분석하는 것과 같다

어댑티브 플러시 알고리즘은 리두 로그 증가 속도를
분석해서 적절한 수준의 더티 페이지가
버퍼풀에 유지뢸 수 있도록 디스크 쓰기를 실행한다

innodb_adaptive_flushing_lwm
기본값은 10%인데
전체 리두 로그 공간에서 
활성 리두 로그의 공간이 10%를 넘어서면
그때부터 어댑티브 플러시 알고리즘이 작동하게 된다

innodb_flush_neighbors
이웃 페이지들의 동시 쓰기
예전에 HDD 의 경우 디스크 읽고 쓰기가 매우 고비용 작업
그래서 한번이라도 읽고 쓰기를 줄이려고
SSD 를 사용하기 때문에 기본값인 비활성 모드를 유지하는 것이 좋다

---

LRU 리스트 플러시

innodb 엔진은 LRU 리스트에서 
사용 빈도가 낮은 데이터 페이지들을 제거해서
새로운 페이지들을 읽어올 공간을 만들어야 한다
이를 위해 LRU_list 플러시 함수가 사용된다

LRU 리스트 끝부분부터 시작해서 
최대 innodb_lru_scan_depth 설정된 개수만큼의
페이지들을 스캔한다

스캔하면서 더티 페이지는 디스크에 동기화한다
클린 페이지는 즉시 프리 Free 리스트로 페이지를 옮긴다

---

버퍼풀 상태 백업 및 복구

innodb 서버의 버퍼풀의 쿼리성능에 매우 밀접하다
쿼리 요청이 매우 빈번한 서버를 셧다운했다가 다시 시작하고
서비스를 시작하면 쿼리 성능이 평상시보다 1/10도 안된다
버퍼풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로
디스크에서 데이터를 읽지 않아도 쿼리가 처리되기 때문이다

워밍업
디스크의 데이터가 버퍼풀에 적재돼 있는 상태

mysql5.5 버전에서는 서버를 셧다운했다가 다시 시작하면
서비스 오픈전에 강제 워밍업을 위해
주요테이블과 인덱스에 대해 풀스캔을 한번씩 실행하고
서비스를 오픈했다

mysql5.6 버전부터는 버퍼풀 덤프 및 적재 기능이 도입
서버 셧다운 하기 전에 백업
innodb_buffer_pool_dump_now
ib_buffer_pool 이름의 파일로 생성됨

버퍼풀 백업은 빠르게 진행되지만
복구는 디스크에서 각 테이블의 데이터 페이지를 읽어와야 하므로
느리게 진행된다
show status like 'innodb_buffer_pool_dump_status'\G

---

버퍼풀의 적재 내용 확인

5.6버전부터 infomation_schema 에
innodb_buffer_page 테이블에
innodb 버퍼풀의 메모리에 
어떤 테이블의 페이지들이 적재돼 있는지 확인 할 수 있다

innodb 버퍼풀이 큰 경우
이 테이블 조회가 상상한 부하를 일으키면서
서비스 쿼리가 느려지는 문제가 있었다

8.0버전에서 부터 이를 해결
infomation_schema 데이터베이스에
innodb_cached_indexes 테이블이 새로 추가됨

---

Double Write Buffer

innodb 엔진의 리두 로그는
리두 로그 공간 낭비를 막기 위해
페이지의 변경된 내용만 기록한다

더티 페이지를 디스크파일로 플러시할때
일부만 기록되는 문제가 발생하면
그 페이지의 내용은 복수할 수 없을 수도 있다
이렇게 페이지 일부만 기록되는 현상을
partial-page 파셜 페이지
torn-page 톤 페이지

innodb 엔진은 이 문제를 막기 위해 double-write 기법을 이요

innodb_doublewrite 시스템 변수
double-write 기능 사용 여부

---

언두 로그

innodb 엔진은 트랜젝션과 격리수준을 보장하기위해
dml로 변경되기 이전 버전의 데이터를 별도로 백업한다
이렇게 백업된 데이터를 언두로그 undo log 라고 한다

언두 로그 사용
트랜잭션 보장
격리 수준 보장

---

언두 로그 레코드 모니터링

격리수준과 언두로그의 사용법에 대한 자세한 설명은
5.4.3절 repeatable read 에 나온 예제를 참고
180페이지

mysql5.5 이전에서
한번 증가한 언두 로그 공간은 다시 줄어들지 않았다
1억건의 레코드가 저장된 100GB 테이블을
delete 로 삭제한다고 가정하면
1억건의 레코드가 테이블에서는 삭제되지만
언두 로그로 복사돼야 한다

대용량 데이터를 처리하는 트랜잭션 뿐 아니라
트랜잭션이 오랜 시간 동안 실행될 때도
언두 로그의 양은 급격히 증가할 수 있다

5.7과 8.0으로 업그레이드 되면서
언두 로그 공간의 문제점은 완전히 해결됐다

mysql 서버의 언두 로그 레코드가
얼마나 되는지 항상 모니터링하는 것이 좋은데
언두 로그 레코드 건수 확인
show engine innodb status \G

트랜잭션 영역의 이부분
History list length 31

```
TRANSACTIONS
------------
Trx id counter 2048
Purge done for trx's n:o < 2047 undo n:o < 0 state: running but idle
History list length 1
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 562947563011288, not started
0 lock struct(s), heap size 1128, 0 row lock(s)
...
---TRANSACTION 2047, ACTIVE 7 sec
2 lock struct(s), heap size 1128, 2 row lock(s), undo log entries 2
MySQL thread id 39, OS thread handle 281472432820096, query id 10082 172.18.0.1 root
Trx read view will not see trx with id >= 2048, sees < 2048
```

---

언두 테이블스페이스 관리

언두 로그가 저장되는 공간을 언두 테이블스페이스 라고 한다

5.6 이전 버전
언두 로그가 모두 시스템 테이블 스페이스 ibdata.ibd 에 저장됨
innodb_undo_tablespaces 시스템변수
2보다 큰값을 설정하면 innodb 엔진은 언두 로그를 
시스템 테이블스페이스에 저장하지 않고
별도의 언두 로그파일을 사용한다

8.0.14 부터
innodb_undo_tablespaces 시스템 변수는 효력이 없음
언두 로그는 항상 시스템 테이블스페이스
외부의 별도 로그 파일에 기록되도록 개선됐다

1개의 언두 테이블스페이스는
1개 이상 128개 이하의 롤백 세그먼트를 가지며
롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다

언두 로그 관련 시스템 변수를 변경해야 한다면
적절히 필요한 
동시 트랜잭션 개수에 맞게
언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다

동시 트랜잭션 개수
언두 테이블스페이스
롤백 세그먼트 개수

언두 테이블스페이스 공간을 필요한 만큼만 남기고
운영체제로 반납하는 것을 
undo tablespace truncate 라고 한다

8.0부터 지원된다

---

체인지 버퍼

체인지 버퍼
인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는
작업이 필요하므로 테이블에 인덱스가 많다면
이 작업은 상당히 많은 자원을 소모한다
그래서 innodb 는 변경해야 할 인덱스 페이지가
버퍼풀에 있으면 바로 업데이트를 수행하지만
그렇지않으면 임시 공간에 저장해 두고 
바로 사용자에게 결과를 반환하는 형태로 성능을 향상 시킨다
이때 사용하는 임시 메모리 공간을 체인지 버퍼 라고 한다

유니크 인덱스, 체인지 버퍼
사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는
유니크 인덱스는 체인지 버퍼를 사용할 수 없다

체인지 버퍼 머지 스레드
체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은
이후 백그라운드 스레드에 의해 병합된다
이 스레드를 체인지 버퍼 머지 스레드 라고 한다

5.5이전 버전까지는 인서트 버퍼라고 했다
insert 작업에 대해서만 버퍼링이 가능했다

inndb_change_buffering
5.5부터는 작업의 종류별로 체인지 버퍼를 활성화 할 수 있다

innodb_change_buffer_max_size
체인지 버퍼가 너무 많은 버퍼풀 공간을 사용하지 못하도록 하거나
insert update 등이 너무 빈번하게 실행되어
체인지 버퍼가 더 많은 버퍼풀을 사용할 수 있게 하고자 한다면
시스템 변수 비율을 설정하면 된다

select EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
from performance_schema.memory_summary_global_by_event_name
where EVENT_NAME = 'memory/innodb/ibuf0ibuf'

---

리두 로그 및 로그 버퍼

리두 로그는 하드웨어나 소프트웨어 등 여러가지 문제점으로 인해
mysql 서버가 비정상적으로 종료됐을때 
데이터 파일에 기록되지 못한 데이터를 
잃지 않게 해주는 안전장치이다

대부분 데이터베이스 서버는 데이터 변경 내용을
로그로 먼저 기록한다
그래서 일부 dbms 는 리두 로그를 WAL 로그라고 한다
Write Ahead Log
디스크에 기록하기 전에 먼저 기록되는 로그라는 의미

innodb_flush_log_at_trx_commit
innodb 엔진에서 리두 로그를 어느 주기로 디스크에 
동기화 할지를 결정하는 시스템 변수를 제공한다

innodb_log_file_size
innodb 엔진의 리두 로그 파일들의 전체 크기는
innodb 엔진이 가지고 있는 버퍼풀의 효율성을 결정하기 때문에
신중히 결정해야 한다

innodb_log_files_in_group
리두 로그 파일의 개수를 결정한다

그래서 전체 리두 로그 파일의 크기는 두 변수의 곱으로 결정한다

로그 버퍼의 크기는 기본값인 16MB
BLOG, TEXT 와 같이 큰 데이터를 자주 변경하는 경우에는
더 크게 설정하는것이 좋다

---

리두 로그 아카이빙

8.0부터 innodb 엔진의 리두 로그를 아카이빙 할 수 있다

UDF: user defined function 사용자 정의 함수

---

리두 로그 활성화 및 비활성화

리두 로그 = 트랜잭션 로그

8.0부터는 수동으로 리두 로그를 활성화, 비활성화 할 수 있다

alter instance disable INNODB REDO_LOG;
load data ... // 대량 데이터 적재
alter instance enable INNODB REDO_LOG;

innodb_redo_log_enabled

---

어댑티브 해시 인덱스

일반적으로 인덱스 라고 하면 이는 테이블에 사용자가 생성해둔
b-tree 인덱스를 의미한다

사용자가 수동으로 생성하는 인덱스가 아니라
innodb 엔진에서 사용자가 자주 요청하는 데이터에 대해
자동으로 생성하는 인덱스이며
innodb_adaptive_hash_index 변수를 이용해서
활성화, 비활성화 할 수 있다

어댑티브 해시 인덱스는 버퍼풀에 올려진 데이터 페이지에 대해서만 관리된다
버퍼풀에 로딩된 페이지 주소를 값으로 가지는 해시 인덱스이다

어댑티브 해시 인덱스는 하나의 메모리 객체인 이유로
경합이 상당히 심하다
8.0부터 세마포어 내부잠금 경합을 줄이기 위해
어댑티브 해시 인덱스의 파티션 기능을 제공한다

innodb_adaptive_hash_index_parts
파티션 개수를 지정한다
기본값은 8

디스크의 데이터가 innodb 버퍼풀의 크기와 비슷하다
= 이 말은 디스크 읽기가 많지 않다

어뎁티브 해시 인덱스 사용 비율 조회
show engine innodb status
...
insert buffer and adaptive hash index
...
1.03 hash searches/s, 2.6 non-hash searches/s

searches 는 쿼리의 실행 횟수를 의미하는게 아니다
쿼리가 처리되기 위해 내부적으로 키 값의 검색이
몇번 실행됐느냐를 의미한다

---

innodb와 myisam, memory 스토리지 엔진 비교

이전 버전의 mysql 에서
전문검색이나 공간좌표 검색 기능은 myisam 테이블만 지원됐다

memory 스토리지 엔진 또한 동시 처리 성능에 있어서
innodb 엔진을 따라갈 수 없다

하나의 스레드에서만 데이터를 읽고 쓴다면
innodb 보다 빠를 수 있다

동시에 몇십 몇백개의 클라이언트에서 쿼리 요청이 실행되는 경우라면
memory 엔진은 테이블 수준의 잠금으로 인해
제대로된 성능을 내지 못 할 것이다

5.7까지만 해도 memory 엔진이 내부 임시 테이블 용도로 사용됐다
memory 엔진은 가변 길이 타입의 컬럼을 지원하지 않는다
8.0부터는 TempTable 엔진이 memory 엔진을 대체해 사용된다

internal_tmp_mem_storage_engine
내부 임시 테이블을 위해 TempTable 엔진을 사용할지
memory 엔진을 사용할 지 선택할 수 있다

---

myisam 스토리지 엔진 아키텍처

키 캐시

innodb 버퍼풀과 비슷한 역할을 하는 것이 myisam 의 키 캐시
키 버퍼라고도 불린다

myisam 에 대한 내용은 기록 생략...

---

MySQL 로그 파일

---

에러 로그 파일

MySQL 이 시작하는 과정과 관련된 정보성 및 에러 메세지

마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 innodb 트랜잭션 복구 메세지

쿼리 처리 도중에 발생하는 문제에 대한 에러 메세지

비정상적으로 종료된 커넥션 메세지
aborted connection

innodb의 모니터링 또는 상태 조회 명령의 결과 메세지

---

제너럴 쿼리 로그 파일, general log

슬로우 쿼리 로그와는 조금 다르게
제너럴 쿼리 로그는 실행되기 전에 mysql 이 요청을 받으면
바로 기록하기 때문에
쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다

show global variables like 'general_log_file'
파일 경로

---

슬로우 쿼리 로그

long_query_time 초단위 설정

반드시 쿼리가 정상적으로 실행이 완료돼야 슬로우 쿼리 로그에
기록될 수 있다

테이블에 저장하도록 설정해도 csv 스토리지 엔진을 사용하기 때문에
결국 csv 파일로 저장하는 것과 동일하게 작동한다

myisam 이나 memory 엔진에서는 테이블 단위의 잠금을 사용하고
mvcc 와 같은 메커니즘이 없기 때문에
select 쿼리라고 하더라도 lock_time 이 1초 이상
소요될 가능성이 있다

innodb 테이블에 대한 select 쿼리도
lock_time 이 상대적으로 큰 값이 발생할 수 있다
innodb 의 레코드 수준의 잠금이 아닌
mysql 엔진 레벨에서 설정한 
테이블 잠금 때문일 가능성이 높다

mysql 의 잠금 처리는 
mysql 엔진 레벨과 스토리지 엔진 레벨의 
두 가지 레이어로 처리된다

